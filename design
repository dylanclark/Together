
------------
 Fraser Weist and Dylan Clark

 Together.

 design.txt.
------------


**Tutorials that influenced our design**
http://lazyfoo.net/tutorials/SDL/ for SDL tutorials (tiling, collision checking, rendering, etc.)
http://gamedevgeek.com/tutorials/managing-game-states-in-c/ for help with game state system

Together. is a game that relies on SDL Frameworks to create a window and render objects. We used C++ to take advantage of these SDL Frameworks. It has two characters who interact with objects in their environments to solve puzzles. Here are several high-level descriptions of major design features we implemented:

- Save file.
    Simple file stream mechanics - functions are defined in the "engine" class object (which runs the game) which can write a new value into the save file (just a .txt) or read the current save value. Those allow a user to continue from the highest level they have reached (using the level select to revisit an old level doesn't influence the save file).
- Menu and pause screens.
    Each menu button (or menu "slider") is programmed to change the level-state to a new menu, or to push a new level state onto the stack so the previous menu is still running (and accessible) underneath it. The active menu button (the one to be selected with the space bar) is changed with the up and down arrow keys.
- Options.
    Players can change the music and sound effect volume. These are two "slider" objects which change the active frame if the user presses left or right on their keyboard. Controls screen is currently unimplemented.
- Switching characters.
    The black dot interacts with black tiles on a white background. The white character interacts with white tiles on a black background. If the player pressed shift on their keyboard, the other character is selected, and the environment changes its appearance to reflect which character will be interacting with it. Objects like crates may appear as crates while "active" and blend in with the environment when "inactive" to make the two worlds that each character interacts with seem different.
- Gamepad / Controller support.
    The SDL library includes functions which allow the game to search for a connected joystick on initialization. If a joystick is detected, the game creates an additional controller class which enables controller input and gameplay.
- Pushable crates.
    Like I described before, these crates can be moved by one character to change the environment that the other character interacts with. If the colors of the dot and the crate it's colliding with are the same, the character pushes the sides and collides with the top and bottom. If the colors of the character and crate are different, the character only interacts with the tiles the crate has generated (to blend in with the environment) and not the level tiles so the character can "pass through" the crate.
- Engine / gamestate system.
    In order to run a game with multiple different levels or "scenes" in it, we implemented a game engine which treats each scene as a "level-state" and stores those level states on a stack data structure. When the engine updates the game, draws to the screen, and handles input, it hands those tasks to the level-state on the top of the stack, and then that level-state updates its own values and draws its own objects. When moving through menus, the base menu always stays in the stack while new ones are opened so that the user can cycle through menus quickly. When the game is being played, the menu states are deallocated, removed from the stack, and the level is placed on the stack so that it's the only level-state on the stack, and the game can run as quickly as possible.
- Tile drawing.
    Tiles are drawn differently depending on which character is being controlled - their "active state" is determined based on the "active state" of the character of the same color, and they are animated by clipping the tile texture based on a frame variable defined in the tile's init and update functions.
- Keyboard input.
    The SDL library uses a stack data structure to store each and every keyboard or mouse event registered by the computer. To respond to these inputs, each level state has a "handle_events" functions which delegates certain objects to interpret those events and respond accordingly based on which key is being pressed / lifted or which controller event has occurred.
- Level select.
    Reads the save file of the game and allows the player to select any level up until their highest. The slider only has as many "frames" as the save file's value.
- Music.
    Simple SDL library music and sound effect functions. A sound player object is defined in the source code and initializes each sound and music file. The sound player is called throughout the program.
- Dynamic camera
    The camera creates a rectangle based on the locations of each character so that it is centered between the two, and wide / tall enough to fit them both on the screen. Then the camera determines how far it's own rectangle's width / height / position is from that target rectangle, and it's value's accelerate to match them (that way it's nice and smooth).

- Collision detection.
    The basis of our dots' interactions with the level objects is our collision checker, found in collisions.cpp. This function detects the magnitude of collisions between collision rectangles and allows for logic based on when things are colliding. For example, if colliding in the y-direction with a tile who's floor boolean value is set to true, a dot's y-velocity will be set to 0.
- Gravity
    Each time a dot's position is updated in "characters::move," gravity effects it negatively before any other movement is applied.
- Jumping
    If touching a floor, a character can jump by having its y-velocity increased by a set amount.
- Levels
    Levels are designed as delimited CSV's with tile numbers associated with different textures and behaviors (defined in tiles.hpp). These are rendered (see Tile Drawing) along with all objects that are necessary on a given level. Their textures, all created in the Pickle Pixel Art App, are loaded via each level state's load_textures function. The objects are all defined as their own classes, and are initialzed in each level state's init_objects function. The attributes of each class are modifieable in this initialization, allowing for things like buttons being set to single-use, springs being set to have x-velocity effects upon springing. After including a render for each object, they'll show up on screen. The level state's interactions function is where we define object interactions (for example, if both dots are on the level-end objects, the game state changes to the next level. If the black dot hits the button on level 6, it creates the crate necessary for completion).
- Level end.
    These objects allow for testing for completion of level. If both dots are on level end objects, the game state can change to the next level. Their code can be found in "level_end.cpp"
- Customizeable springs and cross-layer springs.
   ("springboard.cpp") Springs can be one-sided springboards that launch a dot regardless of the position of another dot or can be cross-layer springs. Cross layer springs  can be based on velocity, in which case  they spring the springee the same velocity as the springer hitting the spring, or they can be position based, where they spring a set amount but require contact from both dots to work. Springs (both regular springboards and cross-layer springs) have customizeable attributes upon initialization in the level state files such as amount of x_spring and y_spring and horizontal direction of spring.
- Customizeable buttons.
    Buttons ("button.cpp")are similarly customizeable in that they can be single or multi use and can be rendered to face any direction. The buttons are used in level state's interactions functions and when pressed can trigger the initialization of an object necessary for level completion (such as initilizing a crate or springboard).
- Flipping/turning when rendering
    This feature, used for buttons and springs, allows for an easy way to define objects facing different directions (ie a button that faces right when the default texture has the button facing up). It requires the angle_render function found in "textures.cpp" and allows for syntax such as "w_button.direction = RIGHT" to do the necessary flipping and angle changing while rendering this object.
- Simple animation.
    This feature is used for object movements (springs springing, buttons pressing) and when the active character changes (tiles, crates, characters animate to change active color). It relies on textures made in Pickle that are many "frames" wide. For example, if the spring animation takes 4 frames, the spring texture is 4 tiles wide, each one the successive frame in the animation. The animation logic (found in source files for anything that animates... all mostly the same but sometimes slightly different) relies on 4 "states": Active, Inactivating, Inactive, and Activating. Status of active renders the first tile of the texture, inactive renders the last tile of the texture, and activating and inactivating cyle through the middle tiles of each .png texture before resting on either active or inactive, respectively.